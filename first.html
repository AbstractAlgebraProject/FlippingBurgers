<!DOCTYPE html>

<html>
<head>
<meta charset='UTF-8'>
	<title> JavaScript Tut1 </title>
	<body>
		<link rel="stylesheet" href="css/style.css">
		<script type="text/javascript" src="dist/paper-full.js"></script>

		<script type="text/paperscript" canvas="myCanvas">



	        function symTri(center, radius) {
	        	this.myTriangle = new Path();
	        	this.speed = .2;
	        	this.center = center;
	        	this.radius = radius;
	        	for (i = 0; i < 3; i++) 
	        	{
					this.myTriangle.add(new Point(radius * Math.cos(Math.PI / 2 + (i * Math.PI * 2 / 3)) + center.x, radius * Math.sin(Math.PI / 2 + (i * Math.PI * 2 / 3)) + center.y));
	        	}

	        	this.textOne = new PointText(this.myTriangle.segments[0].point);
	        	this.textOne.content = "A";
		        this.textOne.fillColor = 'blue';
		        this.textOne.scale(3);
		        this.textTwo = new PointText(this.myTriangle.segments[1].point);
		        this.textTwo.content = "B";
		        this.textTwo.fillColor = 'green';
		    	this.textTwo.scale(3);
		        this.textThree = new PointText(this.myTriangle.segments[2].point);
		        this.textThree.content = "C";
		        this.textThree.fillColor = 'black';
		        this.textThree.scale(3);

		 		this.myTriangle.closed = true;
		        this.myTriangle.fillColor = {gradient: {
            									stops: ['blue', 'red', 'green']
											 },
												origin: this.myTriangle.segments[0].point,
												destination: this.myTriangle.segments[1].point};

		        this.lVertex = this.myTriangle.segments[2];
		        this.rVertex = this.myTriangle.segments[1];
		        this.botCenter = (this.myTriangle.segments[2].point.x + this.myTriangle.segments[1].point.x) / 2;
		        this.halfBotLength = this.botCenter - this.myTriangle.segments[2].point.x;

		        this.isRotate = false;
		        this.isFlip = false;
	        	this.currentFrame = 0;
	       		this.toggle = false;
	       		this.currentABC = "ABC";
	       		this.symmetry = {string: "RRFRFRR", current: 0};
	       		this.setSym = function(sym, resetCurrent) {
	       			if(!resetCurrent) {
	       				this.symmetry.string = sym;
	       			} else {
	       				this.symmetry = { string: sym, current: 0};
	       			}
	       			
	       		};

		    	this.setState = function() {
		    		var c = this.symmetry.current;
		    		
		    		if(c < this.symmetry.string.length) {
		    			var ch = this.symmetry.string.charAt(c);
		    			this.symmetry.current++;
			    		if(ch === 'R') {
			    			this.isFlip = false;
			    			this.isRotate = true;
			    		} else if (ch === 'F') {
			    			this.isRotate = false;
			    			this.isFlip = true;
			    		}
		    		}
		    		
		    	};
	        	//1 is b 2 is c 0 is a
	        	this.currentPoints = [1,2];
	        	this.findPointsToFlip = function() {
	        		var map = {};
	        		map['A'] = 0;
	        		map['B'] = 1;
	        		map['C'] = 2;

	        		this.currentPoints = [map[this.currentABC.charAt(1)], map[this.currentABC.charAt(2)]];
	        		//alert(this.currentPoints);
	        		this.lVertex = this.myTriangle.segments[this.currentPoints[0]];
		        	this.rVertex = this.myTriangle.segments[this.currentPoints[1]];
		       		this.botCenter = (this.myTriangle.segments[this.currentPoints[0]].point.x + this.myTriangle.segments[this.currentPoints[1]].point.x) / 2;
		        	this.halfBotLength = this.botCenter - this.myTriangle.segments[this.currentPoints[0]].point.x;
	        	};



	        	this.Update = function(event) {
	        		if(this.isFlip) {
		        		
			       	    var increment = Math.PI/(60*this.speed); 
			         	           
			       	    if(this.toggle) {
			         	   	var pointVal = Math.cos(increment*this.currentFrame);
			         	} else {
			                var pointVal = Math.cos(increment*this.currentFrame + Math.PI)
			       	    }
					            
				        this.lVertex.point.x = pointVal * this.halfBotLength + this.botCenter;
				        this.rVertex.point.x = pointVal * -this.halfBotLength + this.botCenter;

			            this.currentFrame++;
			            if(this.currentFrame > 60*this.speed) {
				           	this.isFlip = false;
				           	//this.toggle = !this.toggle;
				           	this.currentFrame = 0;
				           	this.setState();
				           	this.currentABC = this.currentABC.charAt(0) + this.currentABC.charAt(2) + this.currentABC.charAt(1);
				           	//alert(this.currentABC);
				           	this.findPointsToFlip();
					    }
		                       
			    	} else if (this.isRotate) {
			    		this.myTriangle.rotate(2/this.speed, this.center);

			    		this.currentFrame++;
			    		if(this.currentFrame >= 60*this.speed) {
			    			this.isRotate = false;
			    			this.currentFrame = 0;
			    			this.setState();
			    			this.currentABC = this.currentABC.charAt(2) + this.currentABC.charAt(0) + this.currentABC.charAt(1);
			    			//alert(this.currentABC);
			    			this.findPointsToFlip();
			    		}
			    	} else {
			    		this.setState();
			    	}

				    //this.myTriangle.rotate(3, center);
				    this.textOne.point = this.myTriangle.segments[0].point;
				    this.textTwo.point = this.myTriangle.segments[1].point;
				    this.textThree.point = this.myTriangle.segments[2].point;
				    this.myTriangle.fillColor = {gradient: {
            									stops: ['blue', 'red', 'green']
											 },
												origin: this.myTriangle.segments[0].point,
												destination: this.myTriangle.segments[1].point};
				    //this.setState();	
		    	};
		    }	

		    function sButton(point, size, color, text, func) {
		    	var rectangle = new Rectangle(point, size);
		    	this.button = new Path.Rectangle(rectangle);
		    	this.button.fillColor = color;
		    	var offset = new Point(0, -100);
		    	this.text = new PointText(point-offset);
		    	this.text.content = text;
		    	this.text.fillColor = color;
		    	this.text.scale(4);
		    	var dothis = func;
		    	this.button.onClick = function(event) {
		    		dothis(event);
		    	}
		    }
	      	var myTri = new symTri(new Point(700, 700), 250);
	      	
	      	myTri.setSym("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", true)
	      	myTri.setState();
	      	

	      	
	      	var but1 = new sButton(new Point(800, 200), new Size(150, 50), 'black', 'R', but1f);
	      	var but2 = new sButton(new Point(600, 200), new Size(150, 50), 'green', 'F', but2f);
	      	function but1f(event) {
	      		myTri.setSym(myTri.symmetry.string + "R", false);
	      		alert(myTri.symmetry.string);
	      	}

	      	function but2f(event) {
	      		myTri.setSym(myTri.symmetry.string + "F", false);
	      		alert(myTri.symmetry.string);
	      	}
	      	//myTri.setSym('RFR');		       	
			//var myTri2 = new symTri(new Point(600, 600), 50);
			var symText = new PointText(new Point(100, 100));
			symText.fillColor = 'red';
			symText.scale(6);

			//myTri.triangle.fillColor = 'blue';	
	      	function onFrame(event) {
	      		symText.content = myTri.symmetry.string + "\n" + myTri.symmetry.string.substring(0, myTri.symmetry.current);
	      		myTri.Update(event);
	      		//myTri2.Update(event);
	      	}
    
		</script>
</head>
	<body>
		<canvas id="myCanvas" resize></canvas>
	</body>
</html>